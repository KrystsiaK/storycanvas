import PDFDocument from 'pdfkit';
import { Story } from '@prisma/client';
import { logger } from '../lib/logger';

export class PDFService {
  async generateStoryPDF(story: Story): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50,
          },
        });

        const buffers: Buffer[] = [];
        doc.on('data', buffers.push.bind(buffers));
        doc.on('end', () => {
          const pdfBuffer = Buffer.concat(buffers);
          resolve(pdfBuffer);
        });
        doc.on('error', reject);

        // Header with decorative elements
        doc
          .fontSize(28)
          .fillColor('#FF6B9D')
          .text('âœ¨ StoryCanvas âœ¨', { align: 'center' })
          .moveDown(0.5);

        // Story Title
        doc
          .fontSize(24)
          .fillColor('#1A1A1A')
          .text(story.title, { align: 'center', underline: true })
          .moveDown(2);

        // Story Metadata
        doc
          .fontSize(12)
          .fillColor('#666666')
          .text(`Genre: ${story.genre}`, { align: 'center' })
          .text(`Age Group: ${story.ageGroup}`, { align: 'center' })
          .text(`Language: ${story.language}`, { align: 'center' })
          .moveDown(2);

        // Decorative line
        doc
          .moveTo(50, doc.y)
          .lineTo(doc.page.width - 50, doc.y)
          .strokeColor('#FF6B9D')
          .lineWidth(2)
          .stroke()
          .moveDown(2);

        // Story Content
        doc
          .fontSize(14)
          .fillColor('#1A1A1A')
          .lineGap(4);

        // Split content into paragraphs
        const paragraphs = story.content.split('\n').filter(p => p.trim());
        paragraphs.forEach((paragraph, index) => {
          // Add drop cap for first paragraph
          if (index === 0 && paragraph.length > 0) {
            const firstLetter = paragraph[0];
            const restOfParagraph = paragraph.slice(1);
            
            doc
              .fontSize(36)
              .fillColor('#FF6B9D')
              .text(firstLetter, { continued: true })
              .fontSize(14)
              .fillColor('#1A1A1A')
              .text(restOfParagraph, { align: 'justify' })
              .moveDown(1.5);
          } else {
            doc
              .fontSize(14)
              .fillColor('#1A1A1A')
              .text(paragraph, { align: 'justify' })
              .moveDown(1.5);
          }

          // Check if we need a new page
          if (doc.y > doc.page.height - 100) {
            doc.addPage();
          }
        });

        // Moral Lesson section (if exists)
        if (story.moralLesson) {
          doc.moveDown(2);
          
          // Decorative line before moral
          doc
            .moveTo(50, doc.y)
            .lineTo(doc.page.width - 50, doc.y)
            .strokeColor('#FF6B9D')
            .lineWidth(1)
            .stroke()
            .moveDown(1);

          doc
            .fontSize(16)
            .fillColor('#FF6B9D')
            .text('ðŸ’¡ Moral of the Story', { align: 'center' })
            .moveDown(0.5);

          doc
            .fontSize(13)
            .fillColor('#666666')
            .text(story.moralLesson, { align: 'center', italics: true })
            .moveDown(1);
        }

        // Footer
        const createdDate = new Date(story.createdAt).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
        });

        doc
          .fontSize(10)
          .fillColor('#999999')
          .text(
            `Created on ${createdDate} | Generated by StoryCanvas`,
            50,
            doc.page.height - 50,
            { align: 'center' }
          );

        // Finalize the PDF
        doc.end();
        
        logger.info(`PDF generated successfully for story: ${story.id}`);
      } catch (error) {
        logger.error('PDF generation error:', error);
        reject(error);
      }
    });
  }

  async generateMultipleStoriesPDF(stories: Story[]): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50,
          },
        });

        const buffers: Buffer[] = [];
        doc.on('data', buffers.push.bind(buffers));
        doc.on('end', () => {
          const pdfBuffer = Buffer.concat(buffers);
          resolve(pdfBuffer);
        });
        doc.on('error', reject);

        // Cover Page
        doc
          .fontSize(32)
          .fillColor('#FF6B9D')
          .text('âœ¨ My Story Collection âœ¨', { align: 'center' })
          .moveDown(1);

        doc
          .fontSize(16)
          .fillColor('#666666')
          .text(`${stories.length} Magical ${stories.length === 1 ? 'Story' : 'Stories'}`, { align: 'center' })
          .moveDown(3);

        // Table of Contents
        doc
          .fontSize(20)
          .fillColor('#1A1A1A')
          .text('Table of Contents', { underline: true })
          .moveDown(1);

        stories.forEach((story, index) => {
          doc
            .fontSize(14)
            .fillColor('#1A1A1A')
            .text(`${index + 1}. ${story.title}`, { indent: 20 })
            .moveDown(0.5);
        });

        // Generate PDF for each story
        stories.forEach((story, index) => {
          doc.addPage();
          
          // Story number
          doc
            .fontSize(12)
            .fillColor('#999999')
            .text(`Story ${index + 1} of ${stories.length}`, { align: 'right' })
            .moveDown(1);

          // Story Title
          doc
            .fontSize(24)
            .fillColor('#1A1A1A')
            .text(story.title, { align: 'center', underline: true })
            .moveDown(1);

          // Story Content (simplified version)
          const paragraphs = story.content.split('\n').filter(p => p.trim());
          paragraphs.forEach(paragraph => {
            doc
              .fontSize(13)
              .fillColor('#1A1A1A')
              .text(paragraph, { align: 'justify' })
              .moveDown(1);

            if (doc.y > doc.page.height - 100) {
              doc.addPage();
            }
          });
        });

        doc.end();
        
        logger.info(`PDF generated successfully for ${stories.length} stories`);
      } catch (error) {
        logger.error('Multiple PDF generation error:', error);
        reject(error);
      }
    });
  }
}

